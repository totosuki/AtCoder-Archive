{ 
  "map(int, input().split())": {
    "scope": "python",
    "prefix": "haha",
    "body": "map(int, input().split())"
  },
  "list(map(int, input().split()))": {
    "scope": "python",
    "prefix": "jaja",
    "body": "list(map(int, input().split()))"
  },
  "[list(map(int, input().split())) for _ in range()]": {
    "scope": "python",
    "prefix": "kaka",
    "body": "[list(map(int, input().split())) for _ in range($1)]"
  },
  "import sys.stdin.buffer.readline": {
    "scope": "python",
    "prefix": "lala",
    "body": "import sys\ninput = sys.stdin.buffer.readline"
  },
  "import os, io": {
    "scope": "python",
    "prefix": ";a;a",
    "body": "import os, io\n_f, _nl, _mb = io.BytesIO(), int(), 10**6\ndef input():\n  global _nl\n  p = _f.tell()\n  while not _nl:\n    bd = os.read(0, _mb)\n    _nl = bd.count(b'\\n') + (not bd)\n    _f.seek(0, 2)\n    _f.write(bd)\n  _f.seek(p)\n  _nl -= 1\n  return _f.readline()"
  },
  "input().decode().strip()": {
    "scope": "python",
    "prefix": "yaya",
    "body": "input().decode().rstrip()"
  },
  "hello_my_name_is_toripppppy": {
    "scope": "python",
    "prefix": "[a[a",
    "body": "def hello_my_name_is_torippppppy_and_this_is_my_first_function_that_can_print_your_original_text_the_name_is_lets_print_the_text_that_specified_at_the_first_argment_of_this_function(text_that_you_want_to_print: str):\n  # your original text that specified at the first argment of this function will print at here\n  print(text_that_you_want_to_print)"
  },
  "main()": {
    "scope": "python",
    "prefix": "launch",
    "body": "def main():\n\t\n\nmain()"
  },
  "defaultdict": {
    "scope": "python",
    "prefix": "dd",
    "body": "from collections import defaultdict"
  },
  "binary_search": {
    "scope": "python",
    "prefix": "binary_search",
    "body": [
      "def check(mid, A, X):",
      "\tpass\n"
      "def binary_search(A, X):",
      "\tleft = ",
      "\tright = ",
      "\twhile right - left > 1:",
      "\t\tmid = (left + right) // 2",
      "\t\tif check(mid, A, X):",
      "\t\t\tright = mid",
      "\t\telse:",
      "\t\t\tleft = mid",
      "\treturn right"
    ]
  },
  "dp_base": {
    "scope": "python",
    "prefix": "dp_base",
    "body": [
      "def dynamic_programming(N, A, B):",
      "\tdp = [0] * (N+1)",
      "\tdp[2] = A[2]",
      "\tfor i in range(3, N+1):",
      "\t\tdp[i] = min(dp[i-1]+A[i], dp[i-2]+B[i])",
      "\treturn dp"
    ]
  },
  "dp_root": {
    "scope": "python",
    "prefix": "dp_root",
    "body": [
      "def dp_root(N, A, B, dp):",
      "\troot = [N]",
      "\ti = N",
      "\twhile i > 1:",
      "\t\tif dp[i-1] + A[i] == dp[i]:",
      "\t\t\troot.append(i-1)",
      "\t\t\ti -= 1",
      "\t\telse:",
      "\t\t\troot.append(i-2)",
      "\t\t\ti -= 2",
      "\treturn root"
    ]
  },
  "dp_sum": {
    "socpe": "python",
    "prefix": "dp_sum",
    "body": [
      "def dynamic_programming(N, S, A):",
      "\tdp = [[False]*(S+1) for _ in range(N+1)]",
      "\tdp[0][0] = True",
      "\tfor i in range(1, N+1):",
      "\t\ta = A[i]",
      "\t\tfor j in range(S+1):",
      "\t\t\tif j < a:",
      "\t\t\t\tdp[i][j] = dp[i-1][j]",
      "\t\t\telse:",
      "\t\t\t\tdp[i][j] = dp[i-1][j] or dp[i-1][j-a]",
      "\treturn dp"
    ]
  },
  "FenwickTree": {
    "scope": "python",
    "prefix": "FenwickTree",
    "body": [
      "class FenwickTree:"
      "\tdef __init__(self, n):"
      "\t\tself._n = n"
      "\t\tself.data = [0] * n"
      "\t"
      "\tdef add(self, id: int, x: int):"
      "\t\t\"\"\"idは 0-indexed\"\"\""
      "\t\tif 0 <= id < self._n:"
      "\t\t\tid += 1 # 0-indexed -> 1-indexed"
      "\t\t\twhile id <= self._n:"
      "\t\t\t\tself.data[id - 1] += x # data を更新"
      "\t\t\t\tid += id & -id # id に LSB(id) を加算"
      "\t\telse:"
      "\t\t\traise ValueError(\"id が  0 <= id < self._n  ではありません。\")"
      "\t"
      "\tdef sum(self, left: int, right: int) -> int:"
      "\t\t\"\"\""
      "\t\t左閉右開の半開区間 [l, r) の部分和を出力する\\n"
      "\t\tleft, right ともに 0-indexed"
      "\t\t\"\"\""
      "\t\tsm = 0 # sum"
      "\t\tif 0 <= left < right <= self._n:"
      "\t\t\treturn self._sum(right) - self._sum(left)"
      "\t\telse:"
      "\t\t\traise ValueError(\"left, right が  0 <= left < right <= self._n  ではありません。\")"
      "\t"
      "\tdef _sum(self, right : int) -> int:"
      "\t\tsm = 0 # sum"
      "\t\twhile right > 0:"
      "\t\t\tsm += self.data[right - 1]"
      "\t\t\tright -= right & -right # right から LSB(right) を減算"
      "\t\treturn sm"
    ]
  }
}